{"m":"//settings\nPOX.setting={\n\tname:\"sample_objs\",\n\tscale:2.0\n};\n\n//scenedata\nnew WWModel().loadObj(\"res/bunny_s.obj\",10.0).then((data)=> {\n\tvar scene={\n\t\tenv:{clear_color:[0.2,0.2,0.4,1.0],cull:false},\n\t\tvs_uni:{\n\t\t\tcol:[1.0,0.2,1.0,1.0]\n\t\t},\n\t\tfs_uni:{\n\t\t\tlvec:[1.0,0.8,0.9],\n\t\t\tmode:0\n\t\t},\n\t\tmodel:[\n\t\t\t//plane\n\t\t\t{geo:new WWModel().primitive(\"plane\",{wx:10,wz:10}).objModel(),\n\t\t\t\tvs_uni:{col:[0.5,0.5,0.5,1.0]},\n\t\t\t\tfs_uni:{mode:2}\n\t\t\t},\n\t\t\t//bunny\n\t\t\t{geo:data.objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(4,-0.4,4),\n\t\t\t\tvs_uni:{col:[1.0,0.0,0.0,1.0]},\n\t\t\t},\n\t\t\t//sphere\n\t\t\t{geo:new WWModel().primitive(\"sphere\",{div:20,wx:1,wy:1,wz:1}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(4,1,0),\n\t\t\t\tvs_uni:{col:[1.0,0.3,0.3,1.0]},\n\t\t\t},\n\t\t\t//box\n\t\t\t{geo:new WWModel().primitive(\"box\",{wx:1,wy:1,wz:1}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(4,1,-4),\n\t\t\t\tvs_uni:{col:[0.3,1.0,0.3,1.0]},\n\t\t\t},\n\t\t\t//cylinder\n\t\t\t{geo:new WWModel().primitive(\"cylinder\",{div:20,wx:0.5,wy:1,wz:0.5}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(-4,1,4),\n\t\t\t\tvs_uni:{col:[1.0,1.0,0.3,1.0]},\n\t\t\t},\n\t\t\t//cone\n\t\t\t{geo:new WWModel().primitive(\"cone\",{div:20,wx:0.5,wy:1,wz:0.5}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(0,1,4),\n\t\t\t\tvs_uni:{col:[0.3,0.3,1.0,1.0]},\n\t\t\t},\n\t\t\t//torus\n\t\t\t{geo:new WWModel().primitive(\"torus\",{div:20,wx:1,wy:1,wz:1}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(-4,1,0),\n\t\t\t\tvs_uni:{col:[1.0,0.3,1.0,1.0]},\n\t\t\t},\n\t\t\t//polyhedron\n\t\t\t{geo:new WWModel().primitive(\"polyhedron\",{shape:\"r05\"}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(-4,1,-4),\n\t\t\t\tvs_uni:{col:[0.3,1.0,1.0,1.0]},\n\t\t\t},\n\t\t\t//parametric (wave) \n\t\t\t{geo:new WWModel().parametricModel(function(u,v){\n\t\t\t\tvar r = Math.sqrt(u*u+v*v) \n\t\t\t\tvar d = Math.cos(r/2*Math.PI)\n\t\t\t\tvar cv = Math.cos(r*4*Math.PI)*d*0.5\n\t\t\t\treturn {\n\t\t\t\t\tpx:u*1,\n\t\t\t\t\tpy:cv*0.4,\n\t\t\t\t\tpz:-v*1,\n\t\t\t\t\tnx:0,ny:0,nz:0,mu:u,mv:v} \t\t\t\t\n\t\t\t\t},{start:-1,end:1.0,div:100},{start:-1,end:1,div:100}).objModel(),\n\t\t\t\tbm:new CanvasMatrix4().translate(0,1,-4),\n\t\t\t\tvs_uni:{col:[0.8,0.8,0.8,1.0]},\n\t\t\t},\t\n\t\t{name:\"axis\",\n\t\t\tgeo:{mode:\"lines\",\n\t\t\t\tvtx_at:[\"position\"],\n\t\t\t\tvtx:[0,0,0,200,0,0,0,0,0,0,200,0,0,0,0,0,0,200]},\n\t\t\tfs_uni:{bcolor:[1.0,1.0,1.0,1.0],mode:1}},\n\t\t]\n\t}\n\n\tthis.setScene(scene) ;\n})\n\n//sceneupdate\nPOX.update=function(render,cam,time){\n\tvar ret={};\n\treturn ret;\n}\t\n","vs":"attribute vec3 position;\nattribute vec3 norm;\nattribute vec2 uv ;\n\nuniform mat4 mvpMatrix;\nuniform mat4 invMatrix;\nuniform vec4 col ;\n\nvarying vec3 tnorm ;\nvarying vec2 tuv ;\nvarying vec4 color ;\n\nvoid main() {\n\ttuv = uv ;\n\tcolor = col ;\n\ttnorm = (invMatrix * vec4(norm,0.0)).xyz ;\n\tgl_Position = mvpMatrix * vec4(position, 1.0) ;\n}\n","fs":"precision highp float;\nuniform int mode ;\nuniform vec4 bcolor ;\nuniform vec3 eyevec ;\nuniform vec3 lvec ;\t\n\nvarying vec3 tnorm ;\nvarying vec2 tuv ;\nvarying vec4 color ;\n\nvoid main() {\n\tvec3 col = color.xyz;\n\tif(mode==2) {  //checker \n\t\tfloat dx = mod(tuv.x*5.0,1.0) ;\n\t\tfloat dy = mod(tuv.y*5.0,1.0) ;\n\t\tfloat t = (dx<0.5) ^^ (dy<0.5)?1.0:0.0 ;\n\t\tcol = vec3(col.x*t,col.y*t,col.z*t) ;\n\t}\n\tvec3 norm = normalize(tnorm) ;\n\tfloat diff= clamp((dot(norm,normalize(lvec))+0.5)/1.5,0.0,1.0);\n\tfloat spec= pow(clamp(dot(norm,normalize(normalize(lvec)+normalize(eyevec))),0.0,1.0),60.0);\n\tvec3 fcolor = col * (diff * 0.8 + 0.2) + vec3(0.6,0.6,1.0)*(spec * 0.8);\n\tgl_FragColor = (mode!=1) ? vec4(fcolor,color.w):vec4(bcolor.x,bcolor.y,bcolor.z,1.0);\n}\n","version":"0.1"}